# FastMCP Best Practices for MCP Server Development

## Overview

This rule provides comprehensive best practices for developing MCP servers using FastMCP 2.0, covering logging, tool design, error handling, testing, and production-ready patterns.

## Core Principles

- **FastMCP 2.0 First**: Use the latest FastMCP features and patterns
- **Pythonic Design**: Write clean, maintainable Python code
- **Production Ready**: Build servers that work reliably in production
- **Client Experience**: Provide excellent user experience through proper logging and error handling
- **Testing**: Comprehensive testing for all functionality

## Tool Development Best Practices

### 1. Tool Design Patterns

**Simple Tools**:
```python
@mcp.tool
def add(a: int, b: int) -> int:
    """Add two numbers together."""
    return a + b
```

**Async Tools with Context**:
```python
@mcp.tool
async def process_data(data: list[float], ctx: Context) -> dict:
    """Process numerical data with comprehensive logging."""
    await ctx.info(f"Processing {len(data)} data points")

    try:
        if not data:
            await ctx.warning("Empty data list provided")
            return {"error": "Empty data list"}

        result = sum(data) / len(data)
        await ctx.info(f"Processing complete, average: {result}")
        return {"average": result, "count": len(data)}

    except Exception as e:
        await ctx.error(f"Processing failed: {str(e)}")
        raise
```

### 2. Parameter Design

**Use Type Annotations**:
```python
@mcp.tool
def validate_user(
    name: str,
    age: int,
    email: str,
    is_active: bool = True
) -> dict:
    """Validate user information."""
    # Tool logic here
    return {"valid": True, "user_id": "123"}
```

**Complex Types**:
```python
from typing import List, Optional, Union
from pydantic import BaseModel

class UserData(BaseModel):
    name: str
    email: str
    preferences: List[str] = []

@mcp.tool
def create_user(user_data: UserData, ctx: Context) -> dict:
    """Create a new user with structured data."""
    await ctx.info(f"Creating user: {user_data.name}")
    # Implementation
    return {"user_id": "123", "status": "created"}
```

### 3. Elicitation Best Practices

**User Choice First**:
```python
@mcp.tool
async def create_resource(param: str, ctx: Context) -> str:
    """Create a resource with user-driven elicitation."""
    if ctx:
        # ✅ GOOD: Present options but let user choose
        await ctx.info("Please choose from the following options:")
        await ctx.info("Available options: option1, option2, option3")
        await ctx.info("⚠️ IMPORTANT: Please choose what YOU prefer. I should not suggest or assume.")

        # ❌ BAD: Don't suggest or assume user preferences
        # await ctx.info("I recommend option1 because it's the most popular")

        result = await ctx.elicit("Which option do you prefer?", response_type=["option1", "option2", "option3"])
        return f"Selected: {result.data}"

    # Handle non-elicitation case
    return "Please provide all parameters directly"
```

**Elicitation Guidelines**:
- **Present options clearly** but don't suggest preferences
- **Let users make the final choice** - don't assume what they want
- **Use clear warnings** like "⚠️ IMPORTANT: Please choose what YOU prefer"
- **Validate user choices** against available options
- **Provide helpful context** without making decisions for users

**Tool Calling with Elicitation**:
- **Only provide required parameters** when elicitation is available
- **Let elicitation handle optional parameters** - don't provide them upfront
- **Use minimal tool calls** with elicitation enabled
- **Example**: `create_stack(ref="blueprint-ref")` instead of `create_stack(ref="blueprint-ref", name="", use_case="")`

### 4. Error Handling

**Comprehensive Error Handling**:
```python
@mcp.tool
async def risky_operation(param: str, ctx: Context) -> str:
    """Perform a risky operation with proper error handling."""
    try:
        await ctx.info(f"Starting risky operation with: {param}")

        # Validate input
        if not param.strip():
            await ctx.warning("Empty parameter provided")
            return "❌ Error: Parameter cannot be empty"

        # Perform operation
        result = perform_operation(param)
        await ctx.info("Operation completed successfully")
        return f"✅ Success: {result}"

    except ValueError as e:
        await ctx.error(f"Validation error: {str(e)}")
        return f"❌ Validation Error: {str(e)}"
    except Exception as e:
        await ctx.error(f"Unexpected error: {str(e)}")
        logger.error("Unexpected error in risky_operation", extra={"error": str(e), "param": param})
        return f"❌ Unexpected Error: {str(e)}"
```

## Logging Guidelines (FastMCP Best Practices)

### 1. Two Types of Logging

**MCP Client Logging** (Context Logging):
- Use `ctx.debug()`, `ctx.info()`, `ctx.warning()`, `ctx.error()` for sending messages to MCP clients
- Add optional `ctx: Any = None` parameter to all tool methods
- Use for real-time progress, debugging, and user feedback
- Always check `if ctx:` before calling context logging methods

**Standard Server-Side Logging**:
- Use `fastmcp.utilities.logging.get_logger(__name__)` for server-side logging
- Use for writing to files, console, or external logging systems
- Follow Python's built-in logging patterns with `extra` parameter

### 2. Logging Implementation Patterns

**Context Logging in Tools**:
```python
async def tool_method(self, param: str, ctx: Any = None) -> str:
    if ctx:
        await ctx.info(f"Starting tool execution with param: {param}")
        await ctx.debug("Tool execution", extra={"param": param, "timestamp": time.time()})

    try:
        # Tool logic here
        result = "success"
        if ctx:
            await ctx.info("Tool completed successfully")
        return result
    except Exception as e:
        if ctx:
            await ctx.error(f"Tool failed: {str(e)}", extra={"error": str(e)})
        logger.error("Tool execution failed", extra={"error": str(e)})
        return f"❌ Error: {str(e)}"
```

**Server-Side Logging**:
```python
from fastmcp.utilities.logging import get_logger

logger = get_logger(__name__)

# Correct usage with extra parameter
logger.info("Operation completed", extra={"count": 5, "duration": 1.2})
logger.error("Operation failed", extra={"error": str(e), "context": "validation"})
```

### 3. Log Levels Usage

- **Debug**: Detailed information for diagnosing problems
- **Info**: General information about normal execution
- **Warning**: Potentially harmful situations that don't prevent execution
- **Error**: Error events that might still allow the application to continue

### 4. Structured Logging with `extra`

Always use the `extra` parameter for structured data:
```python
# ✅ Correct
logger.info("Processing data", extra={"count": len(data), "type": "json"})
await ctx.info("Processing data", extra={"count": len(data), "type": "json"})

# ❌ Incorrect (keyword arguments not supported)
logger.info("Processing data", count=len(data), type="json")
```

### 5. Logging Best Practices

- **Never use `print()` statements** - use proper logging utilities
- **Always check `if ctx:`** before context logging calls
- **Use structured logging** with `extra` parameter for queryable data
- **Provide meaningful messages** with context
- **Log at appropriate levels** (debug, info, warning, error)
- **Include error context** when logging exceptions
- **Use consistent patterns** across all components

## Server Configuration Best Practices

### 1. Server Setup

**Basic Server**:
```python
from fastmcp import FastMCP

mcp = FastMCP("MyServer")

# Add tools and resources here

if __name__ == "__main__":
    mcp.run()
```

**Advanced Server with Configuration**:
```python
from fastmcp import FastMCP

mcp = FastMCP(
    name="ProductionServer",
    on_duplicate_tools="error",  # Strict duplicate handling
    tool_serializer=global_tool_serializer  # Custom serialization
)

# Add middleware for logging
from fastmcp.server.middleware.logging import LoggingMiddleware
mcp.add_middleware(LoggingMiddleware())
```

### 2. Duplicate Tool Handling

Configure how the server handles duplicate tool names:
```python
# Options: "warn" (default), "error", "replace", "ignore"
mcp = FastMCP("StrictServer", on_duplicate_tools="error")
```

### 3. Middleware Integration

**Logging Middleware**:
```python
from fastmcp.server.middleware.logging import LoggingMiddleware, StructuredLoggingMiddleware

# Basic logging middleware
mcp.add_middleware(LoggingMiddleware())

# Structured JSON logging for production
mcp.add_middleware(StructuredLoggingMiddleware())
```

## Testing Best Practices

### 1. In-Memory Testing

Use FastMCP's built-in testing capabilities:
```python
import pytest
from fastmcp import FastMCP, Client

@pytest.fixture
def mcp_server():
    server = FastMCP("TestServer")

    @server.tool
    def greet(name: str) -> str:
        return f"Hello, {name}!"

    return server

async def test_tool_functionality(mcp_server):
    # Pass the server directly to the Client constructor
    async with Client(mcp_server) as client:
        result = await client.call_tool("greet", {"name": "World"})
        assert "Hello, World!" in str(result[0])
```

### 2. Testing with Context

Test tools that use MCP context:
```python
async def test_tool_with_context(mcp_server):
    async with Client(mcp_server) as client:
        # Test tool that uses ctx parameter
        result = await client.call_tool("process_data", {"data": [1, 2, 3]})
        assert result[0].get("average") == 2.0
```

## Resource Development Best Practices

### 1. Resource Design

**Simple Resources**:
```python
@mcp.resource
def get_config() -> str:
    """Get application configuration."""
    return "config: value"
```

**Dynamic Resources**:
```python
@mcp.resource
async def get_user_data(user_id: str) -> str:
    """Get user data by ID."""
    # Fetch user data
    user_data = await fetch_user(user_id)
    return json.dumps(user_data)
```

### 2. Resource Caching

Use appropriate caching strategies:
```python
@mcp.resource
@mcp.cache(ttl=300)  # Cache for 5 minutes
def get_static_data() -> str:
    """Get static data that doesn't change often."""
    return "static data"
```

## Production Deployment Best Practices

### 1. Environment Configuration

**Environment Variables**:
```python
import os
from fastmcp import FastMCP

# Configure based on environment
debug_mode = os.getenv("DEBUG", "false").lower() == "true"

mcp = FastMCP(
    name="ProductionServer",
    on_duplicate_tools="error" if not debug_mode else "warn"
)
```

### 2. Error Handling

**Global Error Handling**:
```python
@mcp.tool
async def robust_tool(param: str, ctx: Context) -> str:
    """Tool with comprehensive error handling."""
    try:
        await ctx.info(f"Processing: {param}")
        result = await process_parameter(param)
        await ctx.info("Processing completed")
        return result
    except Exception as e:
        await ctx.error(f"Processing failed: {str(e)}")
        logger.error("Tool execution failed", extra={
            "error": str(e),
            "param": param,
            "tool": "robust_tool"
        })
        return f"❌ Error: {str(e)}"
```

### 3. Performance Optimization

**Async Operations**:
```python
@mcp.tool
async def efficient_tool(data: list, ctx: Context) -> dict:
    """Efficient tool using async operations."""
    await ctx.info(f"Processing {len(data)} items")

    # Use async operations for I/O
    results = await asyncio.gather(*[
        process_item(item) for item in data
    ])

    await ctx.info("Processing completed")
    return {"results": results, "count": len(results)}
```

## Security Best Practices

### 1. Input Validation

**Validate All Inputs**:
```python
from pydantic import BaseModel, validator

class UserInput(BaseModel):
    name: str
    email: str

    @validator('email')
    def validate_email(cls, v):
        if '@' not in v:
            raise ValueError('Invalid email format')
        return v

@mcp.tool
def create_user(user_input: UserInput, ctx: Context) -> dict:
    """Create user with validated input."""
    await ctx.info(f"Creating user: {user_input.name}")
    # Implementation
    return {"user_id": "123", "status": "created"}
```

### 2. Sensitive Data Handling

**Never Log Sensitive Data**:
```python
@mcp.tool
def process_credentials(username: str, password: str, ctx: Context) -> str:
    """Process user credentials securely."""
    await ctx.info(f"Processing credentials for user: {username}")
    # Never log password or sensitive data
    # logger.info("Password processed", extra={"password": password})  # ❌ WRONG

    # Process credentials
    result = authenticate_user(username, password)
    return "Authentication completed"
```

## Code Organization Best Practices

### 1. Modular Design

**Separate Concerns**:
```python
# tools/user_management.py
from fastmcp import FastMCP

def register_user_tools(mcp: FastMCP):
    @mcp.tool
    def create_user(name: str, email: str) -> dict:
        # Implementation
        pass

    @mcp.tool
    def delete_user(user_id: str) -> dict:
        # Implementation
        pass

# main.py
from fastmcp import FastMCP
from tools.user_management import register_user_tools

mcp = FastMCP("UserServer")
register_user_tools(mcp)
mcp.run()
```

### 2. Configuration Management

**Centralized Configuration**:
```python
# config.py
from pydantic import BaseSettings

class Settings(BaseSettings):
    api_url: str = "https://api.example.com"
    timeout: int = 30
    debug: bool = False

    class Config:
        env_prefix = "APP_"

# main.py
from fastmcp import FastMCP
from config import Settings

settings = Settings()
mcp = FastMCP("ConfiguredServer")
# Use settings in your tools
```

## Best Practices Summary

### Do's ✅
- Use FastMCP 2.0 features and patterns
- Implement comprehensive logging with context
- Write comprehensive tests using in-memory testing
- Use type annotations for all parameters
- Handle errors gracefully with proper logging
- Use structured logging with `extra` parameter
- Validate all inputs using Pydantic models
- Use async operations for I/O-bound tasks
- Implement proper error handling and recovery
- Use middleware for cross-cutting concerns

### Don'ts ❌
- Don't use `print()` statements for logging
- Don't ignore FastMCP context logging capabilities
- Don't skip input validation
- Don't log sensitive data
- Don't use synchronous operations for I/O
- Don't ignore error handling
- Don't use keyword arguments in logging calls
- Don't skip testing
- Don't hardcode configuration values
- Don't ignore security best practices

## References

- [FastMCP Documentation](https://gofastmcp.com/)
- [FastMCP Logging Guide](https://gofastmcp.com/servers/logging)
- [FastMCP Tools Guide](https://gofastmcp.com/servers/tools)
- [FastMCP Testing Guide](https://gofastmcp.com/patterns/testing)

- **Provide meaningful messages** with context
- **Log at appropriate levels** (debug, info, warning, error)
- **Include error context** when logging exceptions
- **Use consistent patterns** across all components
