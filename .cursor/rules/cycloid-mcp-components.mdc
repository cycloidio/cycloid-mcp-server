---
description: Rules for developing Cycloid MCP components using the optimized modular architecture pattern
globs: src/components/**/*.py,tests/test_*_component.py
---

# Cycloid MCP Component Development Rules

## Component Architecture Overview

The Cycloid MCP Server uses an optimized modular component architecture with automatic registration and BaseHandler inheritance. Each component follows consistent patterns that reduce boilerplate, improve type safety, and enable automatic discovery.

## Component Structure

### Directory Organization
```
src/components/[feature_name]/
├── __init__.py              # Export all classes
├── [feature]_handler.py     # Core utilities and private functions
├── [feature]_tools.py       # MCP tools (@mcp_tool decorated functions)
└── [feature]_resources.py   # MCP resources (@mcp_resource decorated functions)
```

### File Responsibilities

1. **`[feature]_handler.py`**: Core business logic and utilities
   - **MUST inherit from `BaseHandler`** (from src.base_handler)
   - Gets `self.cli` and `self.logger` automatically from BaseHandler
   - Contains private utility methods and shared logic
   - Uses `@handle_errors` decorator for consistent error handling
   - Imports types from `src.types` (JSONDict, JSONList, etc.)

2. **`[feature]_tools.py`**: MCP Tools
   - Inherits from `MCPMixin`
   - Contains `@mcp_tool` decorated methods
   - Uses handler for core logic
   - Exposes functionality to MCP clients
   - Uses proper type annotations from `src.types`

3. **`[feature]_resources.py`**: MCP Resources
   - Inherits from `MCPMixin`
   - Contains `@mcp_resource` decorated methods
   - Uses handler for core logic
   - Provides data resources to MCP clients
   - Uses proper type annotations from `src.types`

## Component Implementation Patterns

### Handler Class Template
```python
"""Feature handler utilities and core logic."""

# Standard library imports
import asyncio
from typing import Optional

# Third-party imports
from fastmcp.utilities.logging import get_logger

# Local imports
from src.base_handler import BaseHandler
from src.cli_mixin import CLIMixin
from src.error_handling import handle_errors
from src.types import JSONDict, JSONList, OptionalString

class FeatureHandler(BaseHandler):
    """Core feature operations and utilities."""

    def __init__(self, cli: CLIMixin):
        """Initialize handler with BaseHandler."""
        super().__init__(cli)  # Provides self.cli and self.logger automatically

    @handle_errors(
        action="fetch feature data",
        suggestions=["Check API connectivity", "Verify permissions", "Review CLI configuration"]
    )
    async def get_data(self) -> JSONList:
        """Get data from CLI with unified error handling."""
        data = await self.cli.execute_cli("command", ["args"])
        return self.cli.process_cli_response(data, list_key="items")

    @handle_errors(action="validate feature configuration")
    async def validate_config(self, config: JSONDict) -> bool:
        """Validate configuration with proper error handling."""
        # Validation logic here
        return True
```

### Tools Class Template
```python
"""Feature MCP tools."""

# Standard library imports
import json

# Third-party imports
from fastmcp.contrib.mcp_mixin import MCPMixin, mcp_tool

# Local imports
from src.cli_mixin import CLIMixin
from src.types import JSONList, OptionalString
from .feature_handler import FeatureHandler

class FeatureTools(MCPMixin):
    """Feature MCP tools with optimized patterns."""

    def __init__(self, cli: CLIMixin):
        """Initialize tools with CLI mixin."""
        super().__init__()
        self.handler = FeatureHandler(cli)

    @mcp_tool(
        name="list_items",
        description="List all available items with their details.",
        enabled=True
    )
    async def list_items(self, format: str = "table") -> str:
        """List items in specified format."""
        # Error handling is done by @handle_errors in handler
        data = await self.handler.get_data()

        if format == "json":
            return json.dumps(data, indent=2)
        else:
            return self._format_table(data)

    def _format_table(self, data: JSONList) -> str:
        """Format data as table."""
        if not data:
            return "No items found."

        # Table formatting logic
        return "Formatted table here"
```

### Resources Class Template
```python
"""Feature MCP resources."""

# Standard library imports
import json

# Third-party imports
from fastmcp.contrib.mcp_mixin import MCPMixin, mcp_resource

# Local imports
from src.cli_mixin import CLIMixin
from src.types import JSONDict
from .feature_handler import FeatureHandler

class FeatureResources(MCPMixin):
    """Feature MCP resources with optimized patterns."""

    def __init__(self, cli: CLIMixin):
        """Initialize resources with CLI mixin."""
        super().__init__()
        self.handler = FeatureHandler(cli)

    @mcp_resource("cycloid://feature-resource")
    async def get_feature_resource(self) -> str:
        """Get feature data as a resource."""
        # Error handling is done by @handle_errors in handler
        data = await self.handler.get_data()

        result: JSONDict = {
            "items": data,
            "count": len(data),
            "status": "success"
        }
        return json.dumps(result, indent=2)
```

## Component Development Workflow

### Creating New Components

1. **Create Directory Structure**
   ```bash
   mkdir -p src/components/[feature_name]
   ```

2. **Create Required Files**
   - `__init__.py` - Export classes
   - `[feature]_handler.py` - Core logic
   - `[feature]_tools.py` - MCP tools
   - `[feature]_resources.py` - MCP resources

3. **Follow Naming Conventions**
   - Use lowercase with underscores for file names
   - Use PascalCase for class names
   - Use descriptive names that reflect functionality

4. **No Server.py Changes Needed**
   - Components are automatically discovered and registered
   - The `ComponentRegistry` handles all registration

### Component Registration

- **Automatic Discovery**: Components are found by scanning `*_tools.py` and `*_resources.py` files
- **MCPMixin Detection**: Only classes inheriting from `MCPMixin` are registered
- **CLI Integration**: All components receive `CLIMixin` instance automatically
- **Error Handling**: Failed registrations are logged but don't stop the server

## Testing Patterns

### Test File Structure
```python
"""Tests for [Feature]Component using FastMCP Client pattern."""

import pytest
from unittest.mock import AsyncMock, patch
from fastmcp import FastMCP, Client
from src.components.[feature] import FeatureTools, FeatureResources
from src.cli_mixin import CLIMixin

@pytest.fixture
def [feature]_server():
    """Create a test MCP server with [feature] components."""
    server = FastMCP("Test[Feature]Server")

    # Initialize CLI mixin
    cli = CLIMixin()

    # Create and register components
    tools = FeatureTools(cli)
    resources = FeatureResources(cli)

    tools.register_all(server)
    resources.register_all(server)

    return server

@patch('src.components.[feature].[feature]_handler.CLIMixin')
async def test_list_items(mock_cli_class, [feature]_server):
    """Test list_items tool functionality."""
    # Mock setup
    mock_cli = AsyncMock()
    mock_cli_class.return_value = mock_cli
    mock_cli.execute_cli_json.return_value = [{"test": "data"}]

    # Test using FastMCP Client
    async with Client([feature]_server) as client:
        result = await client.call_tool("list_items", {"format": "json"})
        assert "data" in result.data
```

### Testing Guidelines

1. **Test Both Tools and Resources**
   - Test all `@mcp_tool` decorated methods
   - Test all `@mcp_resource` decorated methods
   - Verify proper error handling

2. **Mock CLI Interactions**
   - Use `@patch` to mock `CLIMixin`
   - Test both success and failure scenarios
   - Verify CLI commands are called correctly

3. **Use FastMCP Client**
   - Test components through the MCP interface
   - Verify tool names and resource URIs
   - Test parameter validation

## Best Practices

### BaseHandler Pattern
- All handlers MUST inherit from `src.base_handler.BaseHandler`
- Use `super().__init__(cli)` to get `self.cli` and `self.logger` automatically
- No need to manually initialize CLI mixin or logger
- Consistent initialization pattern across all handlers

### Error Handling
- Use `@handle_errors` decorator from `src.error_handling` for all CLI operations
- Provide descriptive action names and helpful suggestions
- Let decorator handle `CycloidCLIError` vs `Exception` automatically
- No need for manual try/catch blocks in most cases
- Use `self.logger` (provided by BaseHandler) for consistent logging

### Type Safety
- Import types from `src.types` instead of `typing` directly
- Use `JSONDict`, `JSONList`, `CliFlags`, `OptionalString`, etc.
- Avoid using `Any` - prefer specific type aliases
- Use `ElicitationResult`, `StackCreationParams` for complex operations
- Document complex type structures with proper type annotations

### Memory & Performance Optimization
- Use conditional debug logging: `if logger.isEnabledFor(logger.DEBUG): logger.debug(...)`
- Apply `@lru_cache` only for static data (configuration discovery)
- NEVER cache CLI API responses (dynamic data that changes)
- Use `tempfile.NamedTemporaryFile(delete=True)` for automatic resource cleanup
- Use `execute_cli_command` with `auto_parse` parameter to avoid duplication

### Import Organization
- Follow strict import order: stdlib → third-party → local → relative
- Group imports with blank lines between categories
- Use specific imports from `src.types` for common types
- Keep import statements clean and organized

### Code Organization
- Keep handler methods focused and small (under 50 lines)
- Use descriptive method names with consistent patterns
- Group related functionality together in handlers
- Follow single responsibility principle with BaseHandler pattern
- Use composition over deep inheritance hierarchies

### Template Management
- Store small templates inline in constants.py
- Keep `constants.py` minimal for small constants only

### CLI Integration Patterns
- Use `execute_cli_command` with `auto_parse=True` for JSON responses
- Use `process_cli_response` for standardized response processing
- Handle both success and error scenarios with `@handle_errors`
- Never cache CLI API responses (dynamic data)

### Documentation
- Use clear docstrings for all public methods with proper type annotations
- Document BaseHandler usage and error handling patterns
- Include examples of new architectural patterns in docstrings
- Keep comments up-to-date with optimization changes

## Quality Checklist

### Before Creating Components
- [ ] Understand the feature requirements
- [ ] Plan the component structure
- [ ] Identify shared logic for handler
- [ ] Design tool and resource interfaces

### During Development
- [ ] Follow naming conventions
- [ ] Implement comprehensive error handling
- [ ] Add type hints to all functions
- [ ] Write tests for all functionality
- [ ] Use meaningful variable names

### Before Committing
- [ ] All tests pass
- [ ] Type checking passes (pyright)
- [ ] Code follows PEP 8
- [ ] Documentation is complete
- [ ] Error handling is robust

## Common Patterns

### Data Fetching Pattern
```python
async def _get_data(self) -> List[Dict[str, Any]]:
    """Get data from CLI with proper error handling."""
    try:
        data = await self.cli.execute_cli_json("command", ["args"])
        return data if isinstance(data, list) else data.get("key", [])
    except Exception as e:
        logger.error(f"Failed to fetch data: {str(e)}")
        raise
```

### Output Formatting Pattern
```python
def _format_output(self, data: List[Dict[str, Any]], format: str) -> str:
    """Format data for different output types."""
    if format == "json":
        return json.dumps(data, indent=2)
    else:
        return self._format_table(data)
```

### Resource Error Handling Pattern
```python
@mcp_resource("cycloid://resource")
async def get_resource(self) -> str:
    """Get resource with error handling."""
    try:
        data = await self.handler._get_data()
        return json.dumps({"data": data}, indent=2)
    except CycloidCLIError as e:
        return json.dumps({
            "error": str(e),
            "data": []
        }, indent=2)
```
